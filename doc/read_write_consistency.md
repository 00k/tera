# Tera中读写一致性的保证

## 一、读写时序 - “实读实写”
  * 以写操作返回成功为准，自此刻发起的所有读取操作会返回最新更新成功的数据。
  * 写操作返回成功前，可能读到旧数据，也可能读到新数据。
  * 保证读到全新或全旧的数据，不会出现“残行”。

## 二、原子操作

tera在kv模型的基础上实现了多LocalityGroup及多列数据模型。读写一致性上，tera实现了两种原子语义。

### 1. 原子单行更新
#### 语义
  * 单行中某些列（包含跨LG的列）更新的过程中，在整行commit完成之前，新数据不可见，旧数据可读
  * 直至所有列更新完毕，新版本列同时可被读取
  * 避免出现更新至一半，“残行”出现。
 
#### 实现
  * 更新开始时创建一个临时快照，保证新版本数据生效前旧数据不被删除。
  * 自此发生的所有读取操作基于此快照，保证新写入的数据不被读到。
  * 所有列更新完成后，删除快照，新发生的读取操作作用至新版本数据上。

### 2. 原子数据读取
#### 语义
  * 读取过程中发生的更新，对本次读取不生效，返回更新前数据
  
#### 实现
  * 读取开始时持有一个临时快照
  * 此快照保护所需数据在读取过程中不被删除
  * 以此快照为准进行读取，忽略新更新的数据
  
## 三、内存compact中读写一致性的保证

为了提升高频更新条件下的读写性能，Tera加入内存compact功能：
  * leveldb原LSM结构中，内存是一个单独的skiplist，只能插入无法查询
  * 高频更新的情况下，内存中会存在大量旧版本数据，严重影响读写性能
  * 将skiplist替换为一个内存中的leveldb，支持内存中的数据删除，大幅提升了数据读写性能
  * 
 
内存支持了数据删除后，对上文提到的读写一致性有了影响
  * 内存中可以直接删除数据，导致读取旧版本数据时可能已被删除，可能发生读取失败的情况
  * tera在内存compact的同时，添加了相应的快照保护，保证了此种情况下的读写一致性语义

